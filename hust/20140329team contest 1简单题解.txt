A
字典树，对于区间[L,R]的异或值，是满足区间减法的。即a[L] ^ a[L + 1] ^ ... ^ a[R] = (a[1] ^ a[2] ^ .. ^ a[L - 1]) ^ (a[1] ^ a[2] ^ .. ^ a[R]) (因为a[1]... a[L - 1]全部出现了2次，根据异或性质，是抵消的）。所以我们将a[1] ^ ... a[i]的结果插入trie树中，类似于前缀和的形式，每次对于一个新的a[i + 1],查询a[1],(a[1] ^ a[2]) .. (a[1] ^ .. ^ a[i])有多少个与它异或结果<=M，具体细节看公开代码。

(普及（补充）一个概念，trie树，其实很多时候，可以用动态节点的线段树去模拟，就是一个完全二叉树，每次操作新增LOGN个区间，有兴趣的可以去思考这个问题，木兴趣或者精力的就无所谓了）



B
AC自动机。将输入的M个数转化成二进制字符串，插入到trie中，然后对于每个串的尾节点，标记为危险节点，跑一次自动机。然后求[L,R]中满足条件的数，可以变成求[1,R]中满足条件的数 减去 [1,L - 1]中的数，一个数位DP搞定。



C
矩阵乘法/写得优美一点的DP（参考XDP这个ID的代码）
最简单的方法是用dp[i][j][step]表示起点在 i ，目前到了j点，用了step步的方案数，dp[i][j][step] += cnt(k,j) * dp[i][k][step - 1](k->j有cnt条边)，表示的意义上，第step - 1步我在k点，然后我选择与k的有边相连的j的，走到j。用矩阵乘法优化这个DP即可。

D
一个有向图中求一个点到所有点的最短路，这个用spfa或者dijstra + priority_queue(heap)可以轻松做到。 但是这题多了一个问题，就是求所有点到同一个点S的最短路之和，其实将整个图逆转之后就变成了一个点到所有点的最短路问题（~）



E
方法1，二分
二分答案，然后用部分和可以快速判断区间[i,i + mid - 1]中0的个数。 对于每个mid，只要存在某个[i,i + mid - 1]区间，满足0的个数<=K即符合条件

方法2：two pointers
令 L = 1,R = 1, 每次增大R，如果R大于N，直接结束，否则R ++ ，如果a[R] = 0, zero ++。 如果zero > k, 不断增大L，直到a[L] = 0，ans = max(ans,R - L), L ++

方法3，其实就是方法2
用一个数组sum记录从1到n位置的0的个数，用另一个first数组记录第一个为x的i位置，如果sum[i] <= k，ans = max(ans,i)，否则ans = max(ans,i - first[sum[i] - k]])



F
方法1，贪心
首先，碰到问号先记录下来，碰到其他的符号，直接模拟走到哪里，假设最后的终点是(x,y)，途中在不使用问号的情况下，距离4个边界的最近记录为ans, 最后ans = max(0,ans - cnt（问号)）即可。

方法2.DP
这题中，方格n * n中，n非常大(int)，但是我们注意到实质上操作只有不到1000个，所以最后偏离起始点((n + 1|) / 2,(n + 1) / 2)的距离很小，最多为1000.
同时我们知道，横纵坐标是可以分离的，对于(x,y)，在只考虑左右边界的时候,y是没有意义的，即NS没有任何意义，因此用bool dp[cd_len][x]表示在第cd_len个操作指令后是否来到了x这个坐标。对于y坐标，即上下边界，也要DP一次。



G
经典问题，卡特兰数或者DP
卡特兰数直接为c(2 * n,n) - c(2 * n,n - 1)或者直接O(N)递推

H 
拓扑排序
对于(a,b)，连一条(b,a)的边，拓扑排序，每次找出当前入度为0的点中最大的，给他赋值一个没用过的最大数即可。

I
1）数据范围那么小，直接暴力。。O(N^2)
2）hash，将每个长度为N的串都hash一次，复杂度O(N)
3) 将S变成SS，然后用KMP直接找出S在SS中出现了几次，O(N)
4）直接求出S的next数组，然后直接可以找出循环节了，O(N)
5）SAM/后缀数组（树）等都可以做这类题。


J
斐波那契数。。 在N = 10^9的时候，可以利用矩阵乘法，类似C题的优化解决


K
统计x与x + 1有多少个二进制位不同，直接暴力。。



最后说一句，trie树，AC自动机，矩阵乘法优化，简单DP，最短路算法等，这些基础算法，省赛中都可能涉及到，所以各个队伍尽量将所有的题目都过一次，注意好分工合作。 省赛中，拿个二等啥的，只要基础算法都掌握好了，是没有任何问题的。

